<!-- Copyright (C) The IETF Trust (2009-2013) -->
<!-- Copyright (C) The Internet Society (2010-2013) -->

<section anchor="sec:i18n" title="Internationalization">
  <section anchor="ss:i18n:intro" title="Introduction">
    <t>
      This section describes NFSv4.0 internationalization as implemented
      by existing clients and servers.  As a result, the keywords "MUST",
      "SHOULD", and "MAY", even though they retain their normal
      meanings, reflect patterns of existing implementation:  

      <list style='symbols'>
        <t>
          Behavior implemented by all existing clients or servers is 
          described using "MUST", since new implementations need to follow 
          existing ones to be assured of interoperability.  
        </t>

        <t>
          Behavior implemented by no existing clients or servers is 
          described using "MUST NOT", if such behavior poses interoperability
          problems.   
        </t>

        <t>
          Behavior implemented by most existing clients or servers, where 
          that behavior is more desirable than any alternative is described 
          using "SHOULD", since new implementations need to follow that 
          existing practice unless there are strong reasons to do otherwise. 
          This also holds for "SHOULD NOT".
        </t>

        <t>
          Behavior implemented by some not all existing clients or 
          servers, is described using "MAY", indicating that new 
          implementations have a choice as to whether they will behave in
          that way.
        </t>

        <t>
          Behavior implemented by all existing clients or servers, so far
          as is known, but where there remains some uncertainty as to details 
          is described using "should".  Such cases primary concern details
          of error returns.  New implementations should follow existing 
          practice even though such situations generally do not affect
          interoperability. 
        </t>
      </list>
    </t>
  </section>

  <section anchor="ss:i18n:encode" title="String Encoding">
    <t>
      Strings that potentially contain non-ASCII Characters are represented
      in NFSv4 using the UTF-8 encoding of Unicode.  See [RFC2279] for 
      precise encoding and decoding rules. 
    </t>

    <t>
      Some details of the protocol treatment depend on the type of string:
 
      <list style='symbols'>
        <t>
          For strings that are component names, any non-ASCII characters MUST 
          be represented using the UTF-8 encoding of Unicode.
        </t>

        <t>
          For strings whose form is defined by other internet standards,
          non-ASCII characters MUST be represented using the UTF-8 encoding 
          of Unicode.  In addition other sorts of restrictions defined by
          those standards need to be addressed.  See section 11.4 for details.
        </t>

        <t>
          For other sorts of strings, any non-ASCII characters SHOULD be
          represented using the UTF-8 encoding of Unicode. 
        </t>
      </list>
    </t>
  </section>

  <section anchor="ss:i18n:norms" title="Normalization">
    <t>
      The client and server operating environments may differ in their
      policies and operational methods with respect to character
      normalization (See [Unicode1] for a discussion of normalization
      forms).  This difference may also exist between applications on the
      same client.  This adds to the difficulty of providing a single
      normalization policy for the protocol that allows for maximal
      interoperability.  This issue is similar to the character case issues
      where the server may or may not support case insensitive file name
      matching and may or may not preserve the character case when storing
      file names.  The protocol does not mandate a particular behavior but
      allows for a range of useful behaviors.
    </t>

    <t>
      The NFS version 4 protocol does not mandate the use of a particular
      normalization form at this time.  A subsequent minor version of 
      the NFSv4 protocol might specify a particular normalization form.
      Therefore, the server and client can expect that they may receive
      unnormalized characters within protocol requests and responses.  If
      the operating environment requires normalization, then the
      implementation must normalize the various UTF-8 encoded strings
      within the protocol before presenting the information to an
      application (at the client) or local file system (at the server).
    </t>

    <t>
      Server implementations MAY normalize file names to conform to a 
      particular normalization form before using the resulting string
      when looking up or creating a file.  Servers MAY also perform 
      normalization-insensitive string comparisons without modifying
      name to match a particular normalization form.  Servers MUST NOT
      reject a file name because it doesn't a conform to a particular 
      normalization form. 
    </t>
  </section>

  <section anchor="ss:i18n:types" title="Types with Processing Defined by Other Internet Areas">
    <t>
      There are two types of strings which NFSv4 deals with whose
      processing is defined by other Internet standards, and where issues
      related to different handling choices by server operating systems or
      server file systems do not apply.
    </t>

    <t>
      These are as follows:

      <list style='symbols'>
        <t>
          Server names as they appear in the fs_locations attribute.  Note
          that for most purposes, such server names will only be sent by the
          server to the client.  The exception is use of the fs_locations
          attribute in a VERIFY or NVERIFY operation.
        </t>

        <t>
          Principal suffixes which are used to denote sets of users and
          groups, and are in the form of domain names.
        </t>
      </list>
    </t>

    <t>
      The general rules for handling all of these domain-related strings
      are similar and independent of role the of the sender or receiver as
      client or server although the consequences of failure to obey these
      rules may be different for client or server.  The server can report
      errors when it is sent invalid strings, whereas the client will
      simply ignore invalid string or use a default value in their place.
    </t>

    <t>
      The string sent SHOULD be in the form of a U-label although it MAY be
      in the form of an A-label or a UTF-8 string that would not map to
      itself when canonicalized by applying ToUnicode(ToASCII(...)).  The
      receiver needs to be able to accept domain and server names in any of
      the formats allowed.  The server MUST reject, using the error
      NFS4ERR_INVAL, a string which is not valid UTF-8 or which begins with
      "xn--" and violates the rules for a valid A-label.
    </t>

    <t>
      When a domain string is part of id@domain or group@domain, the server
      SHOULD map domain strings which are A-labels or are UTF-8 domain
      names which are not U-labels, to the corresponding U-label, using
      ToUnicode(domain) or ToUnicode(ToASCII(domain)).  As a result, the
      domain name returned within a userid on a GETATTR may not match that
      sent when the userid is set using SETATTR, although when this
      happens, the domain will be in the form of a U-label.  When the
      server does not map domain strings which are not U-labels into a
      U-label, which it MAY do, it MUST NOT modify the domain and the
      domain returned on a GETATTR of the userid MUST be the same as that
      used when setting the userid by the SETATTR.
    </t>

    <t>
      The server MAY implement VERIFY and NVERIFY without translating
      internal state to a string form, so that, for example, a user
      principal which represents a specific numeric user id, will match a
      different principal string which represents the same numeric user id.
    </t>
  </section>

  <section anchor="ss:i18n:utf8_err" title="UTF-8 Related Errors">
    <t>
      Where the client sends an invalid UTF-8 string, the server SHOULD
      return an NFS4ERR_INVAL error.  This includes cases in which
      inappropriate prefixes are detected and where the count includes
      trailing bytes that do not constitute a full UCS character.
    </t>

    <t>
      Where the client supplied string is not rejected with NFS4ERR_INVAL 
      but contains characters that are not supported by the server as a value 
      for that string (e.g. names containing characters that have more than 
      two octets on a file system that supports Unicode characters only), the
      server should return an NFS4ERR_BADCHAR error.
    </t>

    <t>
      Where a UTF-8 string is used as a file name, and the file system,
      while supporting all of the characters within the name, does not
      allow that particular name to be used, the error should return the
      error NFS4ERR_BADNAME.  This includes situations in which the server
      file system imposes a normalization constraint on name strings, but
      will also include such situations as file system prohibitions of "."
      and ".." as file names for certain operations, and other such
      constraints.
    </t>
  </section>
</section>
