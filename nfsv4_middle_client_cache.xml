<!-- Copyright (C) The IETF Trust (2009-2011) -->
<!-- Copyright (C) The Internet Society (2010-2011) -->
<section anchor="sec:client_caching" title="Client-Side Caching">

  <t>
    Client-side caching of data, of file attributes, and of file names
    is essential to providing good performance with the NFS protocol.
    Providing distributed cache coherence is a difficult problem
    and previous versions of the NFS protocol have not attempted it.
    Instead, several NFS client implementation techniques have been used
    to reduce the problems that a lack of coherence poses for users.
    These techniques have not been clearly defined by earlier protocol
    specifications and it is often unclear what is valid or invalid
    client behavior.
  </t>

  <t>
    The NFSv4 protocol uses many techniques similar to those
    that have been used in previous protocol versions.  The NFSv4
    protocol does not provide distributed cache coherence.  However,
    it defines a more limited set of caching guarantees to allow locks
    and share reservations to be used without destructive interference
    from client side caching.
  </t>

  <t>
    In addition, the NFSv4 protocol introduces a delegation
    mechanism which allows many decisions normally made by the server
    to be made locally by clients.  This mechanism provides efficient
    support of the common cases where sharing is infrequent or where
    sharing is read-only.
  </t>

  <section title="Performance Challenges for Client-Side Caching">

    <t>
      Caching techniques used in previous versions of the NFS protocol have
      been successful in providing good performance.  However, several
      scalability challenges can arise when those techniques are used
      with very large numbers of clients.  This is particularly true when
      clients are geographically distributed which classically increases
      the latency for cache revalidation requests.
    </t>

    <t>
      The previous versions of the NFS protocol repeat their file data
      cache validation requests at the time the file is opened.  This
      behavior can have serious performance drawbacks.  A common case is
      one in which a file is only accessed by a single client.  Therefore,
      sharing is infrequent.
    </t>

    <t>
      In this case, repeated reference to the server to find that no
      conflicts exist is expensive.  A better option with regards to
      performance is to allow a client that repeatedly opens a file to do
      so without reference to the server.  This is done until potentially
      conflicting operations from another client actually occur.
    </t>

    <t>
      A similar situation arises in connection with file locking.  Sending
      file lock and unlock requests to the server as well as the read and
      write requests necessary to make data caching consistent with the
      locking semantics (see <xref target="ss:cc:dcfl" />)
      can severely limit performance.  When locking
      is used to provide protection against infrequent conflicts, a large
      penalty is incurred.  This penalty may discourage the use of file
      locking by applications.
    </t>

    <t>
      The NFSv4 protocol provides more aggressive caching
      strategies with the following design goals:

      <list style='symbols'>
        <t>
          Compatibility with a large range of server semantics.
        </t>

        <t>
          Provide the same caching benefits as previous versions of the NFS
          protocol when unable to provide the more aggressive model.
        </t>

        <t>
          Requirements for aggressive caching are organized so that a large
          portion of the benefit can be obtained even when not all of the
          requirements can be met.
        </t>
      </list>
    </t>

    <t>
      The appropriate requirements for the server are discussed in later
      sections in which specific forms of caching are covered (see 
      <xref target="ss:cc:open_dele" />).
    </t>

  </section>
  <section title="Delegation and Callbacks">

    <t>
      Recallable delegation of server responsibilities for a file to a
      client improves performance by avoiding repeated requests to the
      server in the absence of inter-client conflict.  With the use of a
      "callback" RPC from server to client, a server recalls delegated
      responsibilities when another client engages in sharing of a
      delegated file.
    </t>

    <t>
      A delegation is passed from the server to the client, specifying the
      object of the delegation and the type of delegation.  There are
      different types of delegations but each type contains a stateid to be
      used to represent the delegation when performing operations that
      depend on the delegation.  This stateid is similar to those
      associated with locks and share reservations but differs in that the
      stateid for a delegation is associated with a client ID and may be used
      on behalf of all the open_owners for the given client.  A delegation
      is made to the client as a whole and not to any specific process or
      thread of control within it.
    </t>

    <t>
      Because callback RPCs may not work in all environments (due to
      firewalls, for example), correct protocol operation does not depend
      on them.  Preliminary testing of callback functionality by means of
      a CB_NULL procedure determines whether callbacks can be supported.
      The CB_NULL procedure checks the continuity of the callback path.
      A server makes a preliminary assessment of callback availability to
      a given client and avoids delegating responsibilities until it has
      determined that callbacks are supported.  Because the granting of
      a delegation is always conditional upon the absence of conflicting
      access, clients must not assume that a delegation will be granted
      and they must always be prepared for OPENs to be processed without
      any delegations being granted.
    </t>

    <t>
      Once granted, a delegation behaves in most ways like a lock.  There
      is an associated lease that is subject to renewal together with all
      of the other leases held by that client.
    </t>

    <t>
      Unlike locks, an operation by a second client to a delegated file
      will cause the server to recall a delegation through a callback.
    </t>

    <t>
      On recall, the client holding the delegation must flush modified
      state (such as modified data) to the server and return the
      delegation.  The conflicting request will not be acted on until
      the recall is complete.  The recall is considered complete when
      the client returns the delegation or the server times its wait
      for the delegation to be returned and revokes the delegation as
      a result of the timeout.  In the interim, the server will either
      delay responding to conflicting requests or respond to them with
      NFS4ERR_DELAY.  Following the resolution of the recall, the
      server has the information necessary to grant or deny the second
      client's request.
    </t>

    <t>
      At the time the client receives a delegation recall, it may have
      substantial state that needs to be flushed to the server.  Therefore,
      the server should allow sufficient time for the delegation to be
      returned since it may involve numerous RPCs to the server.  If the
      server is able to determine that the client is diligently flushing
      state to the server as a result of the recall, the server may extend
      the usual time allowed for a recall.  However, the time allowed for
      recall completion should not be unbounded.
    </t>

    <t>
      An example of this is when responsibility to mediate opens on a given
      file is delegated to a client (see <xref target="ss:cc:open_dele" />).
      The server will not know what opens are in effect on the client.
      Without this knowledge the server will be unable to determine if
      the access and deny state for the file allows any particular open
      until the delegation for the file has been returned.
    </t>

    <t>
      A client failure or a network partition can result in failure to
      respond to a recall callback.  In this case, the server will revoke
      the delegation which in turn will render useless any modified state
      still on the client.
    </t>

    <t>
      Clients need to be aware that server implementors may enforce practical
      limitations on the number of delegations issued. Further, as there is
      no way to determine which delegations to revoke, the server is allowed
      to revoke any. If the server is implemented to revoke another delegation
      held by that client, then the client may be able to determine that 
      a limit has been reached because each new delegation request results
      in a revoke. The client could then determine which delegations it may not
      need and preemptively release them.
    </t>


    <section anchor="ss:cc:deleg_recovery" title="Delegation Recovery">

      <t>
        There are three situations that delegation recovery must deal with:

        <list style='symbols'>
          <t>
            Client reboot or restart
          </t>

          <t>
            Server reboot or restart
          </t>

          <t>
            Network partition (full or callback-only)
          </t>
        </list>
      </t>

      <t>
        In the event the client reboots or restarts, the failure to renew
        leases will result in the revocation of byte-range locks and share
        reservations.  Delegations, however, may be treated a bit
        differently.
      </t>

      <t>
        There will be situations in which delegations will need to be
        reestablished after a client reboots or restarts.  The reason for
        this is the client may have file data stored locally and this data
        was associated with the previously held delegations.  The client
        will need to reestablish the appropriate file state on the server.
      </t>

      <t>
        To allow for this type of client recovery, the server MAY extend the
        period for delegation recovery beyond the typical lease expiration
        period.  This implies that requests from other clients that
        conflict with these delegations will need to wait.  Because the
        normal recall process may require significant time for the client to
        flush changed state to the server, other clients need be prepared for
        delays that occur because of a conflicting delegation.  This longer
        interval would increase the window for clients to reboot and consult
        stable storage so that the delegations can be reclaimed.  For open
        delegations, such delegations are reclaimed using OPEN with a claim
        type of CLAIM_DELEGATE_PREV.  (See <xref target="ss:cc:cache_revoke" />
        and <xref target="OP_OPEN" /> for discussion of open
        delegation and the details of OPEN respectively).
      </t>

      <t>
        A server MAY support a claim type of CLAIM_DELEGATE_PREV, but if it
        does, it MUST NOT remove delegations upon SETCLIENTID_CONFIRM, and
        instead MUST, for a period of time no less than that of the value
        of the lease_time attribute, maintain the client's delegations to
        allow time for the client to issue CLAIM_DELEGATE_PREV requests.
        The server that supports CLAIM_DELEGATE_PREV MUST support the
        DELEGPURGE operation.
      </t>

      <t>
        When the server reboots or restarts, delegations are reclaimed (using
        the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to
        byte-range locks and share reservations.  However, there is a slight
        semantic difference.  In the normal case if the server decides that a
        delegation should not be granted, it performs the requested action
        (e.g., OPEN) without granting any delegation.  For reclaim, the
        server grants the delegation but a special designation is applied
        so that the client treats the delegation as having been granted
        but recalled by the server.  Because of this, the client has the
        duty to write all modified state to the server and then return the
        delegation.  This process of handling delegation reclaim reconciles
        three principles of the NFSv4 protocol:

        <list style='symbols'>
          <t>
            Upon reclaim, a client reporting resources assigned to it by an
            earlier server instance must be granted those resources.
          </t>

          <t>
            The server has unquestionable authority to determine whether
            delegations are to be granted and, once granted, whether they are
            to be continued.
          </t>

          <t>
            The use of callbacks is not to be depended upon until the client
            has proven its ability to receive them.
          </t>
        </list>
      </t>

      <t>
        When a client has more than a single open associated with a
        delegation, state for those additional opens can be established using
        OPEN operations of type CLAIM_DELEGATE_CUR.  When these are used to
        establish opens associated with reclaimed delegations, the server
        MUST allow them when made within the grace period.
      </t>

      <t>
        When a network partition occurs, delegations are subject
        to freeing by the server when the lease renewal period
        expires.  This is similar to the behavior for locks and
        share reservations.  For delegations, however, the server may
        extend the period in which conflicting requests are held off.
        Eventually the occurrence of a conflicting request from another
        client will cause revocation of the delegation.  A loss of the
        callback path (e.g., by later network configuration change)
        will have the same effect.  A recall request will fail and
        revocation of the delegation will result.
      </t>

      <t>
        A client normally finds out about revocation of a delegation
        when it uses a stateid associated with a delegation and
        receives the error NFS4ERR_EXPIRED.  It also may find out
        about delegation revocation after a client reboot when it
        attempts to reclaim a delegation and receives that same error.
        Note that in the case of a revoked write open delegation, there
        are issues because data may have been modified by the client
        whose delegation is revoked and separately by other clients.
        See <xref target="ss:cc:rrwod" /> for a discussion of such issues.
        Note also that when delegations are revoked, information about
        the revoked delegation will be written by the server to stable
        storage (as described in <xref target="ss:fl:crash_recov" />).
        This is done to deal with the case in which a server reboots
	after revoking a delegation but before the client holding the
	revoked delegation is notified about the revocation.
      </t>

    </section>
  </section>
  <section title="Data Caching">

    <t>
      When applications share access to a set of files, they need to be
      implemented so as to take account of the possibility of conflicting
      access by another application.  This is true whether the applications
      in question execute on different clients or reside on the same
      client.
    </t>

    <t>
      Share reservations and byte-range locks are the facilities the NFS
      version 4 protocol provides to allow applications to coordinate
      access by providing mutual exclusion facilities.  The NFSv4
			protocol's data caching must be implemented such that it does
      not invalidate the assumptions that those using these facilities
      depend upon.
    </t>

    <section title="Data Caching and OPENs">

      <t>
        In order to avoid invalidating the sharing assumptions that
        applications rely on, NFSv4 clients should not provide cached
        data to applications or modify it on behalf of an application when
        it would not be valid to obtain or modify that same data via a READ
        or WRITE operation.
      </t>

      <t>
        Furthermore, in the absence of open delegation (see <xref
        target="ss:cc:open_dele" />) two additional
        rules apply.  Note that these rules are obeyed in practice
        by many NFSv2 and NFSv3 clients.

        <list style='symbols'>
          <t>
            First, cached data present on a client must be revalidated after
            doing an OPEN.  Revalidating means that the client fetches the
            change attribute from the server, compares it with the cached
            change attribute, and if different, declares the cached data (as
            well as the cached attributes) as invalid.  This is to ensure
            that the data for the OPENed file is still correctly reflected
            in the client's cache.  This validation must be done at least
            when the client's OPEN operation includes DENY=WRITE or BOTH
            thus terminating a period in which other clients may have had
            the opportunity to open the file with WRITE access.  Clients may
            choose to do the revalidation more often (i.e., at OPENs specifying
            DENY=NONE) to parallel the NFSv3 protocol's practice for
            the benefit of users assuming this degree of cache revalidation.

            Since the change attribute is updated for data and metadata
            modifications, some client implementors may be tempted to use the
            time_modify attribute and not change to validate cached data, so
            that metadata changes do not spuriously invalidate clean data.
            The implementor is cautioned in this approach.  The change
            attribute is guaranteed to change for each update to the file,
            whereas time_modify is guaranteed to change only at the granularity
            of the time_delta attribute.  Use by the client's data cache
            validation logic of time_modify and not change runs the risk of
            the client incorrectly marking stale data as valid.
          </t>

          <t>
            Second, modified data must be flushed to the server before closing
            a file OPENed for write.  This is complementary to the first rule.
            If the data is not flushed at CLOSE, the revalidation done after
            client OPENs as file is unable to achieve its purpose.  The other
            aspect to flushing the data before close is that the data must
            be committed to stable storage, at the server, before the CLOSE
            operation is requested by the client.  In the case of a server
            reboot or restart and a CLOSEd file, it may not be possible
            to retransmit the data to be written to the file.  Hence, this
            requirement.
          </t>
        </list>
      </t>

    </section>
    <section anchor="ss:cc:dcfl" title="Data Caching and File Locking">

      <t>
        For those applications that choose to use file locking instead of
        share reservations to exclude inconsistent file access, there is an
        analogous set of constraints that apply to client side data caching.
        These rules are effective only if the file locking is used in a way
        that matches in an equivalent way the actual READ and WRITE
        operations executed.  This is as opposed to file locking that is
        based on pure convention.  For example, it is possible to manipulate
        a two-megabyte file by dividing the file into two one-megabyte
        regions and protecting access to the two regions by file locks on
        bytes zero and one.  A lock for write on byte zero of the file would
        represent the right to do READ and WRITE operations on the first
        region.  A lock for write on byte one of the file would represent the
        right to do READ and WRITE operations on the second region.  As long
        as all applications manipulating the file obey this convention, they
        will work on a local filesystem.  However, they may not work with
        the NFSv4 protocol unless clients refrain from data caching.
      </t>

      <t>
        The rules for data caching in the file locking environment are:

        <list style='symbols'>
          <t>
            First, when a client obtains a file lock for a particular region,
            the data cache corresponding to that region (if any cached data
            exists) must be revalidated.  If the change attribute indicates
            that the file may have been updated since the cached data was
            obtained, the client must flush or invalidate the cached data for
            the newly locked region.  A client might choose to invalidate all
            of non-modified cached data that it has for the file but the only
            requirement for correct operation is to invalidate all of the
            data in the newly locked region.
          </t>

          <t>
            Second, before releasing a write lock for a region, all modified
            data for that region must be flushed to the server.  The modified
            data must also be written to stable storage.
          </t>
        </list>
      </t>

      <t>
        Note that flushing data to the server and the invalidation of
        cached data must reflect the actual byte ranges locked or unlocked.
        Rounding these up or down to reflect client cache block boundaries
        will cause problems if not carefully done.  For example, writing a
        modified block when only half of that block is within an area being
        unlocked may cause invalid modification to the region outside the
        unlocked area.  This, in turn, may be part of a region locked by
        another client.  Clients can avoid this situation by synchronously
        performing portions of write operations that overlap that portion
        (initial or final) that is not a full block.  Similarly, invalidating
        a locked area which is not an integral number of full buffer blocks
        would require the client to read one or two partial blocks from the
        server if the revalidation procedure shows that the data which the
        client possesses may not be valid.
      </t>

      <t>
        The data that is written to the server as a prerequisite to the
        unlocking of a region must be written, at the server, to stable
        storage.  The client may accomplish this either with synchronous
        writes or by following asynchronous writes with a COMMIT operation.
        This is required because retransmission of the modified data after
        a server reboot might conflict with a lock held by another client.
      </t>

      <t>
        A client implementation may choose to accommodate applications which
        use byte-range locking in non-standard ways (e.g., using a byte-range lock as
        a global semaphore) by flushing to the server more data upon a LOCKU
        than is covered by the locked range.  This may include modified data
        within files other than the one for which the unlocks are being done.
        In such cases, the client must not interfere with applications whose
        READs and WRITEs are being done only within the bounds of record
        locks which the application holds.  For example, an application locks
        a single byte of a file and proceeds to write that single byte.  A
        client that chose to handle a LOCKU by flushing all modified data to
        the server could validly write that single byte in response to an
        unrelated unlock.  However, it would not be valid to write the entire
        block in which that single written byte was located since it includes
        an area that is not locked and might be locked by another client.
        Client implementations can avoid this problem by dividing files
        with modified data into those for which all modifications are done
        to areas covered by an appropriate byte-range lock and those for which
        there are modifications not covered by a byte-range lock.  Any writes
        done for the former class of files must not include areas not locked
        and thus not modified on the client.
      </t>

    </section>
    <section title="Data Caching and Mandatory File Locking">

      <t>
        Client side data caching needs to respect mandatory file locking when
        it is in effect.  The presence of mandatory file locking for a given
        file is indicated when the client gets back NFS4ERR_LOCKED from a
        READ or WRITE on a file it has an appropriate share reservation for.
        When mandatory locking is in effect for a file, the client must check
        for an appropriate file lock for data being read or written.  If a
        lock exists for the range being read or written, the client may
        satisfy the request using the client's validated cache.  If an
        appropriate file lock is not held for the range of the read or write,
        the read or write request must not be satisfied by the client's
        cache and the request must be sent to the server for processing.
        When a read or write request partially overlaps a locked region, the
        request should be subdivided into multiple pieces with each region
        (locked or not) treated appropriately.
      </t>

    </section>
    <section anchor="ss:cc:dcfi" title="Data Caching and File Identity">

      <t>
        When clients cache data, the file data needs to be organized
        according to the filesystem object to which the data belongs.  For
        NFSv3 clients, the typical practice has been to assume for
        the purpose of caching that distinct filehandles represent distinct
        filesystem objects.  The client then has the choice to organize and
        maintain the data cache on this basis.
      </t>

      <t>
        In the NFSv4 protocol, there is now the possibility to
        have significant deviations from a "one filehandle per object"
        model because a filehandle may be constructed on the basis of the
        object's pathname.  Therefore, clients need a reliable method to
        determine if two filehandles designate the same filesystem object.
        If clients were simply to assume that all distinct filehandles
        denote distinct objects and proceed to do data caching on this basis,
        caching inconsistencies would arise between the distinct client side
        objects which mapped to the same server side object.
      </t>

      <t>
        By providing a method to differentiate filehandles, the NFSv4
        protocol alleviates a potential functional regression in comparison
        with the NFSv3 protocol.  Without this method, caching
        inconsistencies within the same client could occur and this has not
        been present in previous versions of the NFS protocol.  Note that it
        is possible to have such inconsistencies with applications executing
        on multiple clients but that is not the issue being addressed here.
      </t>

      <t>
        For the purposes of data caching, the following steps allow an NFSv4
        client to determine whether two distinct filehandles denote
        the same server side object:

        <list style='symbols'>
          <t>
            If GETATTR directed to two filehandles returns different values of
            the fsid attribute, then the filehandles represent distinct
            objects.
          </t>

          <t>
            If GETATTR for any file with an fsid that matches the fsid of the
            two filehandles in question returns a unique_handles attribute
            with a value of TRUE, then the two objects are distinct.
          </t>

          <t>
            If GETATTR directed to the two filehandles does not return the
            fileid attribute for both of the handles, then it cannot be
            determined whether the two objects are the same.  Therefore,
            operations which depend on that knowledge (e.g., client side data
            caching) cannot be done reliably. Note that if GETATTR does not
            return the fileid attribute for both filehandles, it will return
            it for neither of the filehandles, since the fsid for both
            filehandles is the same.
          </t>

          <t>
            If GETATTR directed to the two filehandles returns different
            values for the fileid attribute, then they are distinct objects.
          </t>

          <t>
            Otherwise they are the same object.
          </t>
        </list>
      </t>

    </section>
  </section>
  <section anchor="ss:cc:open_dele" title="Open Delegation">

    <t>
      When a file is being OPENed, the server may delegate further handling
      of opens and closes for that file to the opening client.  Any such
      delegation is recallable, since the circumstances that allowed for
      the delegation are subject to change.  In particular, the server may
      receive a conflicting OPEN from another client, the server must recall
      the delegation before deciding whether the OPEN from the other client
      may be granted.  Making a delegation is up to the server and clients
      should not assume that any particular OPEN either will or will not
      result in an open delegation.  The following is a typical set of
      conditions that servers might use in deciding whether OPEN should
      be delegated:

      <list style='symbols'>
        <t>
          The client must be able to respond to the server's callback
          requests.  The server will use the CB_NULL procedure for a test
          of callback ability.
        </t>

        <t>
          The client must have responded properly to previous recalls.
        </t>

        <t>
          There must be no current open conflicting with the requested
          delegation.
        </t>

        <t>
          There should be no current delegation that conflicts with the
          delegation being requested.
        </t>

        <t>
          The probability of future conflicting open requests should be low
          based on the recent history of the file.
        </t>

        <t>
          The existence of any server-specific semantics of OPEN/CLOSE that
          would make the required handling incompatible with the prescribed
          handling that the delegated client would apply (see below).
        </t>
      </list>
    </t>

    <t>
      There are two types of open delegations, read and write.  A read
      open delegation allows a client to handle, on its own, requests to
      open a file for reading that do not deny read access to others.
      Multiple read open delegations may be outstanding simultaneously
      and do not conflict.  A write open delegation allows the client to
      handle, on its own, all opens.  Only one write open delegation may
      exist for a given file at a given time and it is inconsistent with
      any read open delegations.
    </t>

    <t>
      When a client has a read open delegation, it may not make any changes
      to the contents or attributes of the file but it is assured that no
      other client may do so.  When a client has a write open delegation,
      it may modify the file data since no other client will be accessing
      the file's data.  The client holding a write delegation may only
      affect file attributes which are intimately connected with the file
      data:  size, time_modify, change.
    </t>

    <t>
      When a client has an open delegation, it does not send OPENs or
      CLOSEs to the server but updates the appropriate status internally.
      For a read open delegation, opens that cannot be handled locally
      (opens for write or that deny read access) must be sent to the
      server.
    </t>

    <t>
      When an open delegation is made, the response to the OPEN contains an
      open delegation structure which specifies the following:

      <list style='symbols'>
        <t>
          the type of delegation (read or write)
        </t>

        <t>
          space limitation information to control flushing of data on close
          (write open delegation only, see <xref target="ss:cc:oddc" />)
        </t>

        <t>
          an nfsace4 specifying read and write permissions
        </t>

        <t>
          a stateid to represent the delegation for READ and WRITE
        </t>
      </list>
    </t>

    <t>
      The delegation stateid is separate and distinct from the stateid for
      the OPEN proper.  The standard stateid, unlike the delegation
      stateid, is associated with a particular lock_owner and will continue
      to be valid after the delegation is recalled and the file remains
      open.
    </t>

    <t>
      When a request internal to the client is made to open a file and open
      delegation is in effect, it will be accepted or rejected solely on
      the basis of the following conditions.  Any requirement for other
      checks to be made by the delegate should result in open delegation
      being denied so that the checks can be made by the server itself.

      <list style='symbols'>
        <t>
          The access and deny bits for the request and the file as described
          in <xref target="ss:fl:share_res" />.
        </t>

        <t>
          The read and write permissions as determined below.
        </t>
      </list>
    </t>

    <t>
      The nfsace4 passed with delegation can be used to avoid frequent
      ACCESS calls.  The permission check should be as follows:

      <list style='symbols'>
        <t>
          If the nfsace4 indicates that the open may be done, then it should
          be granted without reference to the server.
        </t>

        <t>
          If the nfsace4 indicates that the open may not be done, then an
          ACCESS request must be sent to the server to obtain the definitive
          answer.
        </t>
      </list>
    </t>

    <t>
      The server may return an nfsace4 that is more restrictive than the
      actual ACL of the file.  This includes an nfsace4 that specifies
      denial of all access.  Note that some common practices such as
      mapping the traditional user "root" to the user "nobody" may make
      it incorrect to return the actual ACL of the file in the delegation
      response.
    </t>

    <t>
      The use of delegation together with various other forms of caching
      creates the possibility that no server authentication will ever be
      performed for a given user since all of the user's requests might
      be satisfied locally.  Where the client is depending on the server
      for authentication, the client should be sure authentication occurs
      for each user by use of the ACCESS operation.  This should be the
      case even if an ACCESS operation would not be required otherwise.
      As mentioned before, the server may enforce frequent authentication
      by returning an nfsace4 denying all access with every open delegation.
    </t>

    <section anchor="ss:cc:oddc" title="Open Delegation and Data Caching">

      <t>
        OPEN delegation allows much of the message overhead associated with
        the opening and closing files to be eliminated.  An open when an open
        delegation is in effect does not require that a validation message be
        sent to the server.  The continued endurance of the "read open
        delegation" provides a guarantee that no OPEN for write and thus no
        write has occurred.  Similarly, when closing a file opened for write
        and if write open delegation is in effect, the data written does
        not have to be flushed to the server until the open delegation is
        recalled.  The continued endurance of the open delegation provides
        a guarantee that no open and thus no read or write has been done by
        another client.
      </t>

      <t>
        For the purposes of open delegation, READs and WRITEs done without an
        OPEN are treated as the functional equivalents of a corresponding
        type of OPEN.  This refers to the READs and WRITEs that use the
        special stateids consisting of all zero bits or all one bits.
        Therefore, READs or WRITEs with a special stateid done by another
        client will force the server to recall a write open delegation.
        A WRITE with a special stateid done by another client will force a
        recall of read open delegations.
      </t>

      <t>
        With delegations, a client is able to avoid writing data to the
        server when the CLOSE of a file is serviced.  The file close system
        call is the usual point at which the client is notified of a lack of
        stable storage for the modified file data generated by the
        application.  At the close, file data is written to the server and
        through normal accounting the server is able to determine if the
        available filesystem space for the data has been exceeded (i.e.,
        server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT).  This accounting
        includes quotas.  The introduction of delegations requires that a
        alternative method be in place for the same type of communication
        to occur between client and server.
      </t>

      <t>
        In the delegation response, the server provides either the limit of
        the size of the file or the number of modified blocks and associated
        block size.  The server must ensure that the client will be able to
        flush data to the server of a size equal to that provided in the
        original delegation.  The server must make this assurance for all
        outstanding delegations.  Therefore, the server must be careful in
        its management of available space for new or modified data taking
        into account available filesystem space and any applicable quotas.
        The server can recall delegations as a result of managing the
        available filesystem space.  The client should abide by the server's
        state space limits for delegations.  If the client exceeds the stated
        limits for the delegation, the server's behavior is undefined.
      </t>

      <t>
        Based on server conditions, quotas or available filesystem space, the
        server may grant write open delegations with very restrictive space
        limitations.  The limitations may be defined in a way that will
        always force modified data to be flushed to the server on close.
      </t>

      <t>
        With respect to authentication, flushing modified data to the server
        after a CLOSE has occurred may be problematic.  For example, the user
        of the application may have logged off the client and unexpired
        authentication credentials may not be present.  In this case, the
        client may need to take special care to ensure that local unexpired
        credentials will in fact be available.  This may be accomplished
        by tracking the expiration time of credentials and flushing data
        well in advance of their expiration or by making private copies of
        credentials to assure their availability when needed.
      </t>

    </section>
    <section title="Open Delegation and File Locks">

      <t>
        When a client holds a write open delegation, lock operations may be
        performed locally.  This includes those required for mandatory file
        locking.  This can be done since the delegation implies that there can
        be no conflicting locks.  Similarly, all of the revalidations that
        would normally be associated with obtaining locks and the flushing
        of data associated with the releasing of locks need not be done.
      </t>

      <t>
        When a client holds a read open delegation, lock operations are not
        performed locally.  All lock operations, including those requesting
        non-exclusive locks, are sent to the server for resolution.
      </t>

    </section>
    <section anchor="ss:cc:handle_cb_getattr" title="Handling of CB_GETATTR">

      <t>
        The server needs to employ special handling for a GETATTR where the
        target is a file that has a write open delegation in effect.  The
        reason for this is that the client holding the write delegation may
        have modified the data and the server needs to reflect this change to
        the second client that submitted the GETATTR.  Therefore, the client
        holding the write delegation needs to be interrogated.  The server
        will use the CB_GETATTR operation.  The only attributes that the
        server can reliably query via CB_GETATTR are size and change.
      </t>

      <t>
        Since CB_GETATTR is being used to satisfy another client's GETATTR
        request, the server only needs to know if the client holding the
        delegation has a modified version of the file.  If the client's copy
        of the delegated file is not modified (data or size), the server can
        satisfy the second client's GETATTR request from the attributes stored
        locally at the server.  If the file is modified, the server only needs
        to know about this modified state.  If the server determines that the
        file is currently modified, it will respond to the second client's
        GETATTR as if the file had been modified locally at the server.
      </t>

      <t>
        Since the form of the change attribute is determined by the server
        and is opaque to the client, the client and server need to agree on a
        method of communicating the modified state of the file.  For the size
        attribute, the client will report its current view of the file size.
        For the change attribute, the handling is more involved.
      </t>

      <t>
        For the client, the following steps will be taken when receiving a
        write delegation:

        <list style='symbols'>
          <t>
            The value of the change attribute will be obtained from the server
            and cached.  Let this value be represented by c.
          </t>

          <t>
            The client will create a value greater than c that will be used
            for communicating modified data is held at the client.  Let this
            value be represented by d.
          </t>

          <t>
            When the client is queried via CB_GETATTR for the change
            attribute, it checks to see if it holds modified data.  If the
            file is modified, the value d is returned for the change attribute
            value.  If this file is not currently modified, the client returns
            the value c for the change attribute.
          </t>
        </list>
      </t>

      <t>
        For simplicity of implementation, the client MAY for each CB_GETATTR
        return the same value d.  This is true even if, between successive
        CB_GETATTR operations, the client again modifies in the file's data or
        metadata in its cache.  The client can return the same value because
        the only requirement is that the client be able to indicate to the
        server that the client holds modified data.  Therefore, the value
        of d may always be c + 1.
      </t>

      <t>
        While the change attribute is opaque to the client in the sense that
        it has no idea what units of time, if any, the server is counting
        change with, it is not opaque in that the client has to treat it as an
        unsigned integer, and the server has to be able to see the results
        of the client's changes to that integer.  Therefore, the server
        MUST encode the change attribute in network order when sending it
        to the client.  The client MUST decode it from network order to its
        native order when receiving it and the client MUST encode it network
        order when sending it to the server.  For this reason, change is
        defined as an unsigned integer rather than an opaque array of octets.
      </t>

      <t>
        For the server, the following steps will be taken when providing a
        write delegation:

        <list style='symbols'>
          <t>
            Upon providing a write delegation, the server will cache a copy of
            the change attribute in the data structure it uses to record the
            delegation.  Let this value be represented by sc.
          </t>

          <t>
            When a second client sends a GETATTR operation on the same file to
            the server, the server obtains the change attribute from the first
            client.  Let this value be cc.
          </t>

          <t>
            If the value cc is equal to sc, the file is not modified and the
            server returns the current values for change, time_metadata, and
            time_modify (for example) to the second client.
          </t>

          <t>
            If the value cc is NOT equal to sc, the file is currently modified
            at the first client and most likely will be modified at the server
            at a future time.  The server then uses its current time to
            construct attribute values for time_metadata and time_modify.  A
            new value of sc, which we will call nsc, is computed by the
            server, such that nsc >= sc + 1.  The server then returns the
            constructed time_metadata, time_modify, and nsc values to the
            requester.  The server replaces sc in the delegation record with
            nsc.  To prevent the possibility of time_modify, time_metadata,
            and change from appearing to go backward (which would happen if
            the client holding the delegation fails to write its modified data
            to the server before the delegation is revoked or returned),
            the server SHOULD update the file's metadata record with
            the constructed attribute values.  For reasons of reasonable
            performance, committing the constructed attribute values to stable
            storage is OPTIONAL.
          </t>
        </list>
      </t>

      <t>
        As discussed earlier in this section, the client MAY return the
        same cc value on subsequent CB_GETATTR calls, even if the file was
        modified in the client's cache yet again between successive
        CB_GETATTR calls.  Therefore, the server must assume that the file
        has been modified yet again, and MUST take care to ensure that the
        new nsc it constructs and returns is greater than the previous
        nsc it returned.  An example implementation's delegation record
        would satisfy this mandate by including a boolean field (let us
        call it "modified") that is set to false when the delegation is
        granted, and an sc value set at the time of grant to the change
        attribute value.  The modified field would be set to true the
        first time cc != sc, and would stay true until the delegation
        is returned or revoked.  The processing for constructing nsc,
        time_modify, and time_metadata would use this pseudo code:

        <figure>
          <artwork>
if (!modified) {
    do CB_GETATTR for change and size;

    if (cc != sc)
        modified = TRUE;
} else {
    do CB_GETATTR for size;
}

if (modified) {
    sc = sc + 1;
    time_modify = time_metadata = current_time;

    update sc, time_modify, time_metadata into file's metadata;
}
          </artwork>
        </figure>

        This would return to the client (that sent GETATTR) the attributes
        it requested, but make sure size comes from what
        CB_GETATTR returned. The server would not update the file's
        metadata with the client's modified size.
      </t>

      <t>
        In the case that the file attribute size is different than the
        server's current value, the server treats this as a modification
        regardless of the value of the change attribute retrieved via
        CB_GETATTR and responds to the second client as in the last step.
      </t>

      <t>
        This methodology resolves issues of clock differences between client
        and server and other scenarios where the use of CB_GETATTR break down.
      </t>

      <t>
        It should be noted that the server is under no obligation to use
        CB_GETATTR and therefore the server MAY simply recall the delegation
        to avoid its use.
      </t>

    </section>
    <section title="Recall of Open Delegation">

      <t>
        The following events necessitate recall of an open delegation:

        <list style='symbols'>
          <t>
            Potentially conflicting OPEN request (or READ/WRITE done with
            "special" stateid)
          </t>

          <t>
            SETATTR issued by another client
          </t>

          <t>
            REMOVE request for the file
          </t>

          <t>
            RENAME request for the file as either source or target of the
            RENAME
          </t>
        </list>
      </t>

      <t>
        Whether a RENAME of a directory in the path leading to the file
        results in recall of an open delegation depends on the semantics of
        the server filesystem.  If that filesystem denies such RENAMEs when
        a file is open, the recall must be performed to determine whether
        the file in question is, in fact, open.
      </t>

      <t>
        In addition to the situations above, the server may choose to
        recall open delegations at any time if resource constraints make
        it advisable to do so.  Clients should always be prepared for the
        possibility of recall.
      </t>

      <t>
        When a client receives a recall for an open delegation, it needs
        to update state on the server before returning the delegation.
        These same updates must be done whenever a client chooses to return
        a delegation voluntarily.  The following items of state need to be
        dealt with:

        <list style='symbols'>
          <t>
            If the file associated with the delegation is no longer open and
            no previous CLOSE operation has been sent to the server, a CLOSE
            operation must be sent to the server.
          </t>

          <t>
            If a file has other open references at the client, then OPEN
            operations must be sent to the server.  The appropriate stateids
            will be provided by the server for subsequent use by the client
            since the delegation stateid will not longer be valid.  These OPEN
            requests are done with the claim type of CLAIM_DELEGATE_CUR.  This
            will allow the presentation of the delegation stateid so that the
            client can establish the appropriate rights to perform the OPEN.
            (see <xref target="OP_OPEN" /> for details.)
          </t>

          <t>
            If there are granted file locks, the corresponding LOCK operations
            need to be performed.  This applies to the write open delegation
            case only.
          </t>

          <t>
            For a write open delegation, if at the time of recall the file is
            not open for write, all modified data for the file must be flushed
            to the server.  If the delegation had not existed, the client
            would have done this data flush before the CLOSE operation.
          </t>

          <t>
            For a write open delegation when a file is still open at the time
            of recall, any modified data for the file needs to be flushed to
            the server.
          </t>

          <t>
            With the write open delegation in place, it is possible that the
            file was truncated during the duration of the delegation.  For
            example, the truncation could have occurred as a result of an
            OPEN UNCHECKED4 with a size attribute value of zero.  Therefore,
            if a truncation of the file has occurred and this operation has
            not been propagated to the server, the truncation must occur
            before any modified data is written to the server.
          </t>
        </list>
      </t>

      <t>
        In the case of write open delegation, file locking imposes some
        additional requirements.  To precisely maintain the associated
        invariant, it is required to flush any modified data in any region
        for which a write lock was released while the write delegation was in
        effect.  However, because the write open delegation implies no other
        locking by other clients, a simpler implementation is to flush all
        modified data for the file (as described just above) if any write
        lock has been released while the write open delegation was in effect.
      </t>

      <t>
        An implementation need not wait until delegation recall (or deciding
        to voluntarily return a delegation) to perform any of the above
        actions, if implementation considerations (e.g., resource availability
        constraints) make that desirable.  Generally, however, the fact that
        the actual open state of the file may continue to change makes it not
        worthwhile to send information about opens and closes to the server,
        except as part of delegation return.  Only in the case of closing the
        open that resulted in obtaining the delegation would clients be likely
        to do this early, since, in that case, the close once done will not
        be undone.  Regardless of the client's choices on scheduling these
        actions, all must be performed before the delegation is returned,
        including (when applicable) the close that corresponds to the open
        that resulted in the delegation.  These actions can be performed
        either in previous requests or in previous operations in the same
        COMPOUND request.
      </t>

    </section>
    <section title="Clients that Fail to Honor Delegation Recalls">

      <t>
        A client may fail to respond to a recall for various reasons, such as
        a failure of the callback path from server to the client.  The client
        may be unaware of a failure in the callback path.  This lack of
        awareness could result in the client finding out long after the
        failure that its delegation has been revoked, and another client has
        modified the data for which the client had a delegation.  This is
        especially a problem for the client that held a write delegation.
      </t>

      <t>
        The server also has a dilemma in that the client that fails to
        respond to the recall might also be sending other NFS requests,
        including those that renew the lease before the lease expires.
        Without returning an error for those lease renewing operations,
        the server leads the client to believe that the delegation it has
        is in force.
      </t>

      <t>
        This difficulty is solved by the following rules:

        <list style='symbols'>
          <t>
            When the callback path is down, the server MUST NOT revoke the
            delegation if one of the following occurs:

            <list style='symbols'>
              <t>
                The client has issued a RENEW operation and the server has
                returned an NFS4ERR_CB_PATH_DOWN error.  The server MUST renew
                the lease for any byte-range locks and share reservations the
                client has that the server has known about (as opposed to
                those locks and share reservations the client has established
                but not yet sent to the server, due to the delegation).
                The server SHOULD give the client a reasonable time to return
                its delegations to the server before revoking the client's
                delegations.
              </t>

              <t>
                The client has not issued a RENEW operation for some period of
                time after the server attempted to recall the delegation.
                This period of time MUST NOT be less than the value of the
                lease_time attribute.
              </t>
            </list>
          </t>

          <t>
            When the client holds a delegation, it cannot rely on operations,
            except for RENEW, that take a stateid, to renew delegation leases
            across callback path failures.  The client that wants to keep
            delegations in force across callback path failures must use RENEW
            to do so.
          </t>
        </list>
      </t>

    </section>
    <section title="Delegation Revocation">

      <t>
        At the point a delegation is revoked, if there are associated opens
        on the client, the applications holding these opens need to be
        notified.  This notification usually occurs by returning errors for
        READ/WRITE operations or when a close is attempted for the open file.
      </t>

      <t>
        If no opens exist for the file at the point the delegation is
        revoked, then notification of the revocation is unnecessary.
        However, if there is modified data present at the client for
        the file, the user of the application should be notified.
        Unfortunately, it may not be possible to notify the user
        since active applications may not be present at the client.
        See <xref target="ss:cc:rrwod" /> for additional details.
      </t>

    </section>
  </section>
  <section anchor="ss:cc:cache_revoke" title="Data Caching and Revocation">

    <t>
      When locks and delegations are revoked, the assumptions upon which
      successful caching depend are no longer guaranteed.  For any locks or
      share reservations that have been revoked, the corresponding owner
      needs to be notified.  This notification includes applications with a
      file open that has a corresponding delegation which has been revoked.
      Cached data associated with the revocation must be removed from the
      client.  In the case of modified data existing in the client's cache,
      that data must be removed from the client without it being written to
      the server.  As mentioned, the assumptions made by the client are no
      longer valid at the point when a lock or delegation has been revoked.
      For example, another client may have been granted a conflicting lock
      after the revocation of the lock at the first client.  Therefore, the
      data within the lock range may have been modified by the other client.
      Obviously, the first client is unable to guarantee to the application
      what has occurred to the file in the case of revocation.
    </t>

    <t>
      Notification to a lock owner will in many cases consist of simply
      returning an error on the next and all subsequent READs/WRITEs to the
      open file or on the close.  Where the methods available to a client
      make such notification impossible because errors for certain
      operations may not be returned, more drastic action such as signals
      or process termination may be appropriate.  The justification for
      this is that an invariant for which an application depends on may
      be violated.  Depending on how errors are typically treated for the
      client operating environment, further levels of notification including
      logging, console messages, and GUI pop-ups may be appropriate.
    </t>

    <section anchor="ss:cc:rrwod" title="Revocation Recovery for Write Open Delegation">

      <t>
        Revocation recovery for a write open delegation poses the special
        issue of modified data in the client cache while the file is not
        open.  In this situation, any client which does not flush modified
        data to the server on each close must ensure that the user receives
        appropriate notification of the failure as a result of the revocation.
        Since such situations may require human action to correct problems,
        notification schemes in which the appropriate user or administrator
        is notified may be necessary.  Logging and console messages are
        typical examples.
      </t>

      <t>
        If there is modified data on the client, it must not be flushed
        normally to the server.  A client may attempt to provide a copy of
        the file data as modified during the delegation under a different
        name in the filesystem name space to ease recovery.  Note that when
        the client can determine that the file has not been modified by any
        other client, or when the client has a complete cached copy of file
        in question, such a saved copy of the client's view of the file
        may be of particular value for recovery.  In other case, recovery
        using a copy of the file based partially on the client's cached
        data and partially on the server copy as modified by other clients,
        will be anything but straightforward, so clients may avoid saving
        file contents in these situations or mark the results specially to
        warn users of possible problems.
      </t>

      <t>
        Saving of such modified data in delegation revocation situations may
        be limited to files of a certain size or might be used only when
        sufficient disk space is available within the target filesystem.
        Such saving may also be restricted to situations when the client
        has sufficient buffering resources to keep the cached copy available
        until it is properly stored to the target filesystem.
      </t>

    </section>
  </section>
  <section title="Attribute Caching">

    <t>
      The attributes discussed in this section do not include named
      attributes.  Individual named attributes are analogous to files and
      caching of the data for these needs to be handled just as data
      caching is for ordinary files.  Similarly, LOOKUP results from an
      OPENATTR directory are to be cached on the same basis as any other
      pathnames and similarly for directory contents.
    </t>

    <t>
      Clients may cache file attributes obtained from the server and use
      them to avoid subsequent GETATTR requests.  Such caching is write
      through in that modification to file attributes is always done by
      means of requests to the server and should not be done locally and
      cached.  The exception to this are modifications to attributes that
      are intimately connected with data caching.  Therefore, extending
      a file by writing data to the local data cache is reflected
      immediately in the size as seen on the client without this change
      being immediately reflected on the server.  Normally such changes are
      not propagated directly to the server but when the modified data is
      flushed to the server, analogous attribute changes are made on the
      server.  When open delegation is in effect, the modified attributes
      may be returned to the server in the response to a CB_RECALL call.
    </t>

    <t>
      The result of local caching of attributes is that the attribute
      caches maintained on individual clients will not be coherent.
      Changes made in one order on the server may be seen in a different
      order on one client and in a third order on a different client.
    </t>

    <t>
      The typical filesystem application programming interfaces do not
      provide means to atomically modify or interrogate attributes for
      multiple files at the same time.  The following rules provide an
      environment where the potential incoherences mentioned above can be
      reasonably managed.  These rules are derived from the practice of
      previous NFS protocols.

      <list style='symbols'>
        <t>
          All attributes for a given file (per-fsid attributes excepted) are
          cached as a unit at the client so that no non-serializability
          can arise within the context of a single file.
        </t>

        <t>
          An upper time boundary is maintained on how long a client cache
          entry can be kept without being refreshed from the server.
        </t>

        <t>
          When operations are performed that change attributes at the
          server, the updated attribute set is requested as part of the
          containing RPC.  This includes directory operations that update
          attributes indirectly.  This is accomplished by following the
          modifying operation with a GETATTR operation and then using the
          results of the GETATTR to update the client's cached attributes.
        </t>
      </list>
    </t>

    <t>
      Note that if the full set of attributes to be cached is requested by
      READDIR, the results can be cached by the client on the same basis
      as attributes obtained via GETATTR.
    </t>

    <t>
      A client may validate its cached version of attributes for a file by
      fetching just both the change and time_access attributes and assuming
      that if the change attribute has the same value as it did when the
      attributes were cached, then no attributes other than time_access
      have changed.  The reason why time_access is also fetched is
      because many servers operate in environments where the operation
      that updates change does not update time_access.  For example, POSIX
      file semantics do not update access time when a file is modified by
      the write system call.  Therefore, the client that wants a current
      time_access value should fetch it with change during the attribute
      cache validation processing and update its cached time_access.
    </t>

    <t>
      The client may maintain a cache of modified attributes for those
      attributes intimately connected with data of modified regular files
      (size, time_modify, and change).  Other than those three attributes,
      the client MUST NOT maintain a cache of modified attributes.
      Instead, attribute changes are immediately sent to the server.
    </t>

    <t>
      In some operating environments, the equivalent to time_access is
      expected to be implicitly updated by each read of the content of the
      file object.  If an NFS client is caching the content of a file
      object, whether it is a regular file, directory, or symbolic link,
      the client SHOULD NOT update the time_access attribute (via SETATTR
      or a small READ or READDIR request) on the server with each read that
      is satisfied from cache.  The reason is that this can defeat the
      performance benefits of caching content, especially since an explicit
      SETATTR of time_access may alter the change attribute on the server.
      If the change attribute changes, clients that are caching the content
      will think the content has changed, and will re-read unmodified data
      from the server.  Nor is the client encouraged to maintain a modified
      version of time_access in its cache, since this would mean that the
      client will either eventually have to write the access time to the
      server with bad performance effects, or it would never update the
      server's time_access, thereby resulting in a situation where an
      application that caches access time between a close and open of the
      same file observes the access time oscillating between the past and
      present.  The time_access attribute always means the time of last
      access to a file by a read that was satisfied by the server.  This
      way clients will tend to see only time_access changes that go forward
      in time.
    </t>

  </section>
  <section title="Data and Metadata Caching and Memory Mapped Files">

    <t>
      Some operating environments include the capability for an application
      to map a file's content into the application's address space.  Each
      time the application accesses a memory location that corresponds to a
      block that has not been loaded into the address space, a page
      fault occurs and the file is read (or if the block does not exist
      in the file, the block is allocated and then instantiated in the
      application's address space).
    </t>

    <t>
      As long as each memory mapped access to the file requires a page
      fault, the relevant attributes of the file that are used to detect
      access and modification (time_access, time_metadata, time_modify,
      and change) will be updated.  However, in many operating environments,
      when page faults are not required these attributes will not be updated
      on reads or updates to the file via memory access (regardless whether
      the file is local file or is being access remotely).  A client or
      server MAY fail to update attributes of a file that is being accessed
      via memory mapped I/O.  This has several implications:

      <list style='symbols'>
        <t>
          If there is an application on the server that has memory mapped a
          file that a client is also accessing, the client may not be able
          to get a consistent value of the change attribute to determine
          whether its cache is stale or not.  A server that knows that
          the file is memory mapped could always pessimistically return
          updated values for change so as to force the application to
          always get the most up to date data and metadata for the file.
          However, due to the negative performance implications of this,
          such behavior is OPTIONAL.
        </t>

        <t>
          If the memory mapped file is not being modified on the server, and
          instead is just being read by an application via the memory
          mapped interface, the client will not see an updated time_access
          attribute.  However, in many operating environments, neither will
          any process running on the server.  Thus NFS clients are at no
          disadvantage with respect to local processes.
        </t>

        <t>
          If there is another client that is memory mapping the file, and if
          that client is holding a write delegation, the same set of issues
          as discussed in the previous two bullet items apply.  So, when a
          server does a CB_GETATTR to a file that the client has modified in
          its cache, the response from CB_GETATTR will not necessarily be
          accurate.  As discussed earlier, the client's obligation is to
          report that the file has been modified since the delegation was
          granted, not whether it has been modified again between successive
          CB_GETATTR calls, and the server MUST assume that any file the
          client has modified in cache has been modified again between
          successive CB_GETATTR calls.  Depending on the nature of the
          client's memory management system, this weak obligation may not
          be possible.  A client MAY return stale information in CB_GETATTR
          whenever the file is memory mapped.
        </t>

        <t>
          The mixture of memory mapping and file locking on the same file is
          problematic.  Consider the following scenario, where the page size
          on each client is 8192 bytes.

          <list style='symbols'>
            <t>
              Client A memory maps first page (8192 bytes) of file X
            </t>

            <t>
              Client B memory maps first page (8192 bytes) of file X
            </t>

            <t>
              Client A write locks first 4096 bytes
            </t>

            <t>
              Client B write locks second 4096 bytes
            </t>

            <t>
              Client A, via a STORE instruction modifies part of its locked
              region.
            </t>

            <t>
              Simultaneous to client A, client B issues a STORE on part of
              its locked region.
            </t>
          </list>
        </t>
      </list>
    </t>

    <t>
      Here the challenge is for each client to resynchronize to get a
      correct view of the first page.  In many operating environments, the
      virtual memory management systems on each client only know a page is
      modified, not that a subset of the page corresponding to the
      respective lock regions has been modified.  So it is not possible
      for each client to do the right thing, which is to only write to
      the server that portion of the page that is locked. For example,
      if client A simply writes out the page, and then client B writes
      out the page, client A's data is lost.
    </t>

    <t>
      Moreover, if mandatory locking is enabled on the file, then we have a
      different problem.  When clients A and B issue the STORE instructions,
      the resulting page faults require a byte-range lock on the entire page.
      Each client then tries to extend their locked range to the entire
      page, which results in a deadlock.
    </t>

    <t>
      Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is
      difficult at best.
    </t>

    <t>
      If a client is locking the entire memory mapped file, there is no
      problem with advisory or mandatory byte-range locking, at least until
      the client unlocks a region in the middle of the file.
    </t>

    <t>
      Given the above issues the following are permitted:

      <list style='symbols'>
        <t>
          Clients and servers MAY deny memory mapping a file they know there
          are byte-range locks for.
        </t>

        <t>
          Clients and servers MAY deny a byte-range lock on a file they know is
          memory mapped.
        </t>

        <t>
          A client MAY deny memory mapping a file that it knows requires
          mandatory locking for I/O.  If mandatory locking is enabled after
          the file is opened and mapped, the client MAY deny the application
          further access to its mapped file.
        </t>
      </list>
    </t>

  </section>
  <section title="Name Caching">

    <t>
      The results of LOOKUP and READDIR operations may be cached to avoid
      the cost of subsequent LOOKUP operations.  Just as in the case of
      attribute caching, inconsistencies may arise among the various client
      caches.  To mitigate the effects of these inconsistencies and given
      the context of typical filesystem APIs, an upper time boundary is
      maintained on how long a client name cache entry can be kept without
      verifying that the entry has not been made invalid by a directory
      change operation performed by another client.
    </t>

    <t>
      When a client is not making changes to a directory for which there
      exist name cache entries, the client needs to periodically fetch
      attributes for that directory to ensure that it is not being
      modified.  After determining that no modification has occurred,
      the expiration time for the associated name cache entries may be
      updated to be the current time plus the name cache staleness bound.
    </t>

    <t>
      When a client is making changes to a given directory, it needs to
      determine whether there have been changes made to the directory by
      other clients.  It does this by using the change attribute as
      reported before and after the directory operation in the associated
      change_info4 value returned for the operation.  The server is able to
      communicate to the client whether the change_info4 data is provided
      atomically with respect to the directory operation.  If the change
      values are provided atomically, the client is then able to compare
      the pre-operation change value with the change value in the client's
      name cache.  If the comparison indicates that the directory was
      updated by another client, the name cache associated with the modified
      directory is purged from the client.  If the comparison indicates
      no modification, the name cache can be updated on the client to
      reflect the directory operation and the associated timeout extended.
      The post-operation change value needs to be saved as the basis for
      future change_info4 comparisons.
    </t>

    <t>
      As demonstrated by the scenario above, name caching requires that the
      client revalidate name cache data by inspecting the change attribute
      of a directory at the point when the name cache item was cached.
      This requires that the server update the change attribute for
      directories when the contents of the corresponding directory
      is modified.  For a client to use the change_info4 information
      appropriately and correctly, the server must report the pre and post
      operation change attribute values atomically.  When the server is
      unable to report the before and after values atomically with respect
      to the directory operation, the server must indicate that fact in the
      change_info4 return value.  When the information is not atomically
      reported, the client should not assume that other clients have not
      changed the directory.
    </t>

  </section>
  <section title="Directory Caching">

    <t>
      The results of READDIR operations may be used to avoid subsequent
      READDIR operations.  Just as in the cases of attribute and name
      caching, inconsistencies may arise among the various client caches.
      To mitigate the effects of these inconsistencies, and given the
      context of typical filesystem APIs, the following rules should be
      followed:

      <list style='symbols'>
        <t>
          Cached READDIR information for a directory which is not obtained
          in a single READDIR operation must always be a consistent snapshot
          of directory contents.  This is determined by using a GETATTR
          before the first READDIR and after the last of READDIR that
          contributes to the cache.
        </t>

        <t>
          An upper time boundary is maintained to indicate the length of
          time a directory cache entry is considered valid before the client
          must revalidate the cached information.
        </t>
      </list>
    </t>

    <t>
      The revalidation technique parallels that discussed in the case
      of name caching.  When the client is not changing the directory in
      question, checking the change attribute of the directory with GETATTR
      is adequate.  The lifetime of the cache entry can be extended at
      these checkpoints.  When a client is modifying the directory, the
      client needs to use the change_info4 data to determine whether there
      are other clients modifying the directory.  If it is determined that
      no other client modifications are occurring, the client may update
      its directory cache to reflect its own changes.
    </t>

    <t>
      As demonstrated previously, directory caching requires that the client
      revalidate directory cache data by inspecting the change attribute of
      a directory at the point when the directory was cached.  This requires
      that the server update the change attribute for directories when the
      contents of the corresponding directory is modified.  For a client
      to use the change_info4 information appropriately and correctly,
      the server must report the pre and post operation change attribute
      values atomically.  When the server is unable to report the before
      and after values atomically with respect to the directory operation,
      the server must indicate that fact in the change_info4 return value.
      When the information is not atomically reported, the client should
      not assume that other clients have not changed the directory.
    </t>

  </section>
</section>
